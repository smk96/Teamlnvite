/// <reference lib="deno.unstable" />

import { Application, Router, Context } from "@oak/oak";
import { join, dirname, fromFileUrl } from "@std/path";
import { DB, Team } from "./lib/db.ts";

const __dirname = dirname(fromFileUrl(import.meta.url));

const app = new Application();
const router = new Router();

// --- API Helpers ---

// Middleware for error handling
app.use(async (ctx, next) => {
  try {
    await next();
  } catch (err) {
    console.error(err);
    ctx.response.status = 500;
    ctx.response.body = { success: false, error: err instanceof Error ? err.message : "Internal Server Error" };
  }
});

// Middleware for Admin Auth
app.use(async (ctx, next) => {
  if (ctx.request.url.pathname.startsWith("/admin") || ctx.request.url.pathname.startsWith("/api/admin")) {
    const adminPassword = Deno.env.get("ADMIN_PASSWORD");
    if (adminPassword) {
      const authHeader = ctx.request.headers.get("Authorization");
      if (!authHeader) {
        ctx.response.status = 401;
        ctx.response.headers.set("WWW-Authenticate", 'Basic realm="Admin Area"');
        return;
      }
      const [type, credentials] = authHeader.split(" ");
      if (type !== "Basic") {
         ctx.response.status = 401;
         return;
      }
      const decoded = atob(credentials);
      const [user, pass] = decoded.split(":");
      // Username can be anything, check password
      if (pass !== adminPassword) {
         ctx.response.status = 403;
         ctx.response.body = "Forbidden";
         return;
      }
    }
  }
  await next();
});

// Middleware for static files
app.use(async (ctx, next) => {
  await next();
  const root = join(__dirname, "static");
  try {
    await ctx.send({ root });
  } catch {
    // Ignore 404 for static files, let router handle it
  }
});


// --- Business Logic Services ---

async function fetchTeamMembers(accessToken: string, accountId: string) {
  const url = `https://chatgpt.com/backend-api/accounts/${accountId}/users`;
  const headers = {
    "accept": "*/*",
    "accept-language": "zh-CN,zh;q=0.9",
    "authorization": `Bearer ${accessToken}`,
    "chatgpt-account-id": accountId,
    "content-type": "application/json",
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
  };

  try {
    const res = await fetch(url, { headers });
    if (res.status === 401) throw new Error("Token expired");
    if (res.status !== 200) throw new Error(`API Error: ${res.status}`);
    const data = await res.json();
    return data.items || [];
  } catch (e) {
    console.error("Fetch members error:", e);
    throw e;
  }
}

async function inviteToTeam(accessToken: string, accountId: string, email: string) {
  const url = `https://chatgpt.com/backend-api/accounts/${accountId}/invites`;
  const headers = {
    "accept": "*/*",
    "authorization": `Bearer ${accessToken}`,
    "chatgpt-account-id": accountId,
    "content-type": "application/json",
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
  };
  
  const body = {
    email_addresses: [email],
    role: "standard-user",
    resend_emails: false
  };

  const res = await fetch(url, {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  });

  if (res.status !== 200 && res.status !== 201) {
    const text = await res.text();
    throw new Error(`Invite failed: ${res.status} - ${text}`);
  }
  return await res.json();
}

async function fetchPendingInvites(accessToken: string, accountId: string) {
  const url = `https://chatgpt.com/backend-api/accounts/${accountId}/invites`;
  const headers = {
    "accept": "*/*",
    "authorization": `Bearer ${accessToken}`,
    "chatgpt-account-id": accountId,
    "content-type": "application/json",
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
  };

  const res = await fetch(url, { headers });
  if (res.status !== 200) {
    const text = await res.text();
    throw new Error(`Fetch invites failed: ${res.status} - ${text}`);
  }
  const data = await res.json();
  return data.items || [];
}

async function revokeInvite(accessToken: string, accountId: string, inviteId: string) {
  const baseUrl = `https://chatgpt.com/backend-api/accounts/${accountId}/invites/${inviteId}`;
  const headers = {
    "accept": "*/*",
    "authorization": `Bearer ${accessToken}`,
    "chatgpt-account-id": accountId,
    "content-type": "application/json",
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
  };

  const attempts = [
    { url: baseUrl, method: "DELETE" },
    { url: `${baseUrl}/revoke`, method: "POST" },
    { url: `${baseUrl}/cancel`, method: "POST" }
  ];

  let lastStatus = 0;
  let lastText = "";
  for (const attempt of attempts) {
    const res = await fetch(attempt.url, {
      method: attempt.method,
      headers,
      body: attempt.method === "POST" ? "{}" : undefined
    });

    if (res.status === 200 || res.status === 204) {
      return true;
    }

    lastStatus = res.status;
    lastText = await res.text();

    if (res.status !== 405) {
      break;
    }
  }

  throw new Error(`Revoke invite failed: ${lastStatus} - ${lastText}`);
}

async function kickMember(accessToken: string, accountId: string, userId: string) {
  const url = `https://chatgpt.com/backend-api/accounts/${accountId}/users/${userId}`;
  const headers = {
    "accept": "*/*",
    "authorization": `Bearer ${accessToken}`,
    "chatgpt-account-id": accountId,
    "content-type": "application/json",
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
  };

  const res = await fetch(url, { method: "DELETE", headers });
  if (res.status !== 200 && res.status !== 204) {
    const text = await res.text();
    throw new Error(`Kick failed: ${res.status} - ${text}`);
  }
  return true;
}

// --- Routes ---

// 1. Pages
router.get("/", async (ctx) => {
  const html = await Deno.readTextFile(join(__dirname, "templates", "index.html"));
  ctx.response.body = html;
});

router.get("/admin", async (ctx) => {
  // Simple auth check (TODO: Real auth)
  const html = await Deno.readTextFile(join(__dirname, "templates", "admin.html"));
  ctx.response.body = html;
});

// 2. Admin API - Teams
router.get("/api/admin/teams", async (ctx) => {
  const teams = await DB.listTeams();
  ctx.response.body = { success: true, teams };
});

router.post("/api/admin/teams", async (ctx) => {
  const body = await ctx.request.body.json();
  const { name, session_data } = body;
  
  try {
    const session = JSON.parse(session_data);
    
    // Validate Session JSON
    // We prioritize checking for an explicit 'accountId' field,
    // because 'user.id' is often 'user-xxx' which is NOT a UUID and fails the API check.
    if (!session.accessToken) {
        ctx.response.status = 400;
        ctx.response.body = { success: false, error: "Invalid Session JSON: Missing accessToken" };
        return;
    }

    const accessToken = session.accessToken;
    // Prefer account.id (original Flask), then accountId, then user.id (may be user-xxx and invalid)
    const accountId = session.account?.id || session.accountId || session.user?.id;
    
    if (!accountId) {
       ctx.response.status = 400;
       ctx.response.body = { success: false, error: "Invalid Session JSON: Missing account.id, accountId or user.id" };
       return;
    }

    await DB.createTeam({
      name,
      accountId,
      accessToken,
      email: session.user?.email // Use optional chaining
    });
    ctx.response.body = { success: true };
  } catch (e) {
    ctx.response.status = 400;
    ctx.response.body = { success: false, error: "Invalid session data or team creation failed" };
  }
});

router.put("/api/admin/teams/:id/token", async (ctx) => {
  const id = ctx.params.id;
  const body = await ctx.request.body.json();
  const { session_data } = body;
  try {
    const session = JSON.parse(session_data);
    await DB.updateTeam(id, {
      accessToken: session.accessToken,
      tokenStatus: "active",
      tokenErrorCount: 0
    });
    ctx.response.body = { success: true };
  } catch (e) {
    ctx.response.body = { success: false, error: "Update failed" };
  }
});

router.delete("/api/admin/teams/:id", async (ctx) => {
  await DB.deleteTeam(ctx.params.id);
  ctx.response.body = { success: true };
});

router.get("/api/admin/teams/:id/members", async (ctx) => {
  const team = await DB.getTeam(ctx.params.id);
  if (!team) {
    ctx.response.status = 404;
    ctx.response.body = { success: false, error: "Team not found" };
    return;
  }

  try {
    const members = await fetchTeamMembers(team.accessToken, team.accountId);
    ctx.response.body = { success: true, members };
  } catch (e) {
    ctx.response.status = 500;
    ctx.response.body = { success: false, error: e instanceof Error ? e.message : "Failed to fetch members" };
  }
});

router.delete("/api/admin/teams/:id/members/:userId", async (ctx) => {
  const team = await DB.getTeam(ctx.params.id);
  if (!team) {
    ctx.response.status = 404;
    ctx.response.body = { success: false, error: "Team not found" };
    return;
  }

  let email = "";
  try {
    if (ctx.request.hasBody) {
      const body = await ctx.request.body.json();
      email = body?.email || "";
    }
  } catch {
    // ignore body parse errors
  }

  try {
    await kickMember(team.accessToken, team.accountId, ctx.params.userId);
    if (email) {
      await DB.deleteInvitationsByEmail(team.id, email);
    }
    ctx.response.body = { success: true };
  } catch (e) {
    ctx.response.status = 500;
    ctx.response.body = { success: false, error: e instanceof Error ? e.message : "Kick failed" };
  }
});

router.get("/api/admin/teams/:id/pending-invites", async (ctx) => {
  const team = await DB.getTeam(ctx.params.id);
  if (!team) {
    ctx.response.status = 404;
    ctx.response.body = { success: false, error: "Team not found" };
    return;
  }

  try {
    const invites = await fetchPendingInvites(team.accessToken, team.accountId);
    ctx.response.body = { success: true, invites };
  } catch (e) {
    ctx.response.status = 500;
    ctx.response.body = { success: false, error: e instanceof Error ? e.message : "Failed to fetch invites" };
  }
});

router.delete("/api/admin/teams/:id/pending-invites/:inviteId", async (ctx) => {
  const team = await DB.getTeam(ctx.params.id);
  if (!team) {
    ctx.response.status = 404;
    ctx.response.body = { success: false, error: "Team not found" };
    return;
  }

  try {
    await revokeInvite(team.accessToken, team.accountId, ctx.params.inviteId);
    ctx.response.body = { success: true };
  } catch (e) {
    ctx.response.status = 500;
    ctx.response.body = { success: false, error: e instanceof Error ? e.message : "Revoke failed" };
  }
});

// 3. Admin API - Keys
router.get("/api/admin/keys", async (ctx) => {
  const keys = await DB.listAccessKeys();
  ctx.response.body = { success: true, keys };
});

router.post("/api/admin/keys", async (ctx) => {
  const { count, is_temp, temp_hours, is_unlimited } = await ctx.request.body.json();
    const createdKeys: any[] = [];
    
    for (let i = 0; i < (count || 1); i++) {
    // Generate random code
    const code = crypto.randomUUID().replace(/-/g, "").substring(0, 16);
    const key = await DB.createAccessKey({
      code,
      isTemp: !!is_temp,
      isUnlimited: !!is_unlimited,
      tempHours: temp_hours || 24
    });
    createdKeys.push({ key_code: key.code, ...key });
  }
  
  ctx.response.body = { success: true, keys: createdKeys };
});

// 4. Join API
router.post("/api/join", async (ctx) => {
  const { email, key_code } = await ctx.request.body.json();
  
  if (!email || !key_code) {
    ctx.response.status = 400;
    ctx.response.body = { success: false, error: "Missing fields" };
    return;
  }

  // 1. Validate Key
  const key = await DB.getAccessKey(key_code);
  if (!key) {
    ctx.response.status = 400;
    ctx.response.body = { success: false, error: "Invalid Key" };
    return;
  }

  // 2. Check if key is used (temp or unlimited keys can be reused)
  // Temp keys and special unlimited keys should allow multiple uses until no available team.
  if (!key.isUnlimited && !key.isTemp && key.usageCount > 0) {
    ctx.response.status = 400;
    ctx.response.body = { success: false, error: "Key already used" };
    return;
  }

  // 3. Find Available Team (actively refresh member count + token status)
  const teams = await DB.listTeams();
  let selectedTeam: Team | null = null;
  const normalizedEmail = email.toLowerCase();

  for (const team of teams) {
    if (team.tokenStatus === "expired") continue;

    try {
      const members = await fetchTeamMembers(team.accessToken, team.accountId);
      const nonOwnerMembers = Array.isArray(members)
        ? members.filter((m: any) => m?.role !== "account-owner")
        : [];
      const memberCount = nonOwnerMembers.length;
      const refreshed = await DB.updateTeam(team.id, { memberCount, tokenStatus: "active" });

      const memberEmails = nonOwnerMembers
        .map((m: any) => String(m?.email || "").toLowerCase())
        .filter(Boolean);

      if (memberEmails.includes(normalizedEmail)) {
        const tempExpireAt = key.isTemp
          ? Date.now() + (key.tempHours || 24) * 3600000
          : undefined;

        await DB.createInvitation({
          teamId: refreshed.id,
          email,
          keyCode: key_code,
          status: "success",
          isTemp: key.isTemp,
          tempExpireAt,
          isConfirmed: false
        });

        await DB.incrementKeyUsage(key_code);

        ctx.response.body = {
          success: true,
          message: `✅ 您已是 ${refreshed.name} 团队成员！`,
          team_name: refreshed.name,
          email
        };
        return;
      }

      if (memberCount < 4 && !selectedTeam) {
        selectedTeam = refreshed;
      }
    } catch (err) {
      console.error("[Join] token expired or member fetch failed", err);
      await DB.updateTeam(team.id, { tokenStatus: "expired" });
    }
  }

  if (!selectedTeam) {
    ctx.response.status = 400;
    ctx.response.body = { success: false, error: "No available teams at the moment" };
    return;
  }

  // 4. Invite
  try {
    await inviteToTeam(selectedTeam.accessToken, selectedTeam.accountId, email);
    
    // 5. Update DB
    await DB.createInvitation({
      teamId: selectedTeam.id,
      email,
      keyCode: key_code,
      status: "success",
      isTemp: key.isTemp,
      tempExpireAt: key.isTemp ? Date.now() + (key.tempHours || 24) * 3600000 : undefined,
      isConfirmed: false
    });
    
    await DB.incrementKeyUsage(key_code);
    
    // Update team member count (cached)
    await DB.updateTeam(selectedTeam.id, { 
      memberCount: selectedTeam.memberCount + 1,
      lastInviteAt: Date.now()
    });

    ctx.response.body = { success: true, message: "Invitation sent! Check your email." };
  } catch (e) {
    // Handle specific errors (e.g. token expired during invite)
    console.error(e);
    if (e.message.includes("401") || e.message.includes("expired")) {
       await DB.updateTeam(selectedTeam.id, { tokenStatus: "expired" });
    }
    ctx.response.status = 500;
    // Expose the error message to help debug (e.g., 401, 404 from upstream)
    ctx.response.body = { success: false, error: `Invite failed: ${e.message}` };
  }
});

// 5. Auto Kick Config
router.get("/api/admin/auto-kick/config", async (ctx) => {
  const config = await DB.getAutoKickConfig();
  ctx.response.body = { success: true, config: {
    enabled: config.enabled,
    check_interval: config.checkInterval,
    start_hour: config.startHour,
    end_hour: config.endHour
  }};
});

router.post("/api/admin/auto-kick/config", async (ctx) => {
  const body = await ctx.request.body.json();
  await DB.setAutoKickConfig({
    enabled: body.enabled,
    checkInterval: body.check_interval,
    startHour: body.start_hour,
    endHour: body.end_hour
  });
  ctx.response.body = { success: true };
});

// --- Auto Kick Job (Deno Cron) ---

Deno.cron("Auto Kick Service", "*/5 * * * *", async () => {
  // Check config
  const config = await DB.getAutoKickConfig();
  if (!config.enabled) return;
  
  const now = new Date();
  const currentHour = now.getHours(); // Local time depends on server
  // Adjust for timezone if needed, assuming server time for now
  
  if (currentHour < config.startHour || currentHour > config.endHour) return;

  console.log("[AutoKick] Starting check...");
  
  // 1. Check Temp Invites Expiration
  const invites = await DB.listInvitations();
  for (const inv of invites) {
    if (inv.isTemp && !inv.isConfirmed && inv.tempExpireAt && Date.now() > inv.tempExpireAt && inv.status === 'success') {
      // Expired! Kick user.
      console.log(`[AutoKick] Expired invite: ${inv.email}`);
      const team = await DB.getTeam(inv.teamId);
      if (team) {
         try {
           const members = await fetchTeamMembers(team.accessToken, team.accountId);
           const member = members.find((m: any) => m.email === inv.email);
           if (member) {
             // DELETE /users/{id}
             // Implementation omitted for brevity, similar to invite
             // Log kick
           }
         } catch (e) {
           console.error(`[AutoKick] Failed to kick ${inv.email}`, e);
         }
      }
    }
  }

  // 2. Full Sync (Check illegal members)
  // ... (Implementation complexity omitted for this step, needs full logic)
});

app.use(router.routes());
app.use(router.allowedMethods());

console.log("Server running on http://localhost:8000");
await app.listen({ port: 8000 });
